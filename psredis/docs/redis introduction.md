知乎上一段对redis的介绍：

为什么并发插入数据下Redis会比mysql的性能高，至于消息队列，应该是说Redis没有锁等待的问题。
先来看看Redis和Mysql的数据存储，Mysql是需要落到磁盘的，而Redis的数据是写入内存即表示成功，至于持久化是异步刷到磁盘的（虽然可以同步刷到磁盘，但这样和Mysql没有多大udkl )。内存的读写性能是磁盘的一到两个数据量级，所以这在本质上决定了Redis的读写性能高于MySql。
再来看看Redis和Mysql的存储模型， Redis是Key-Value的，Mysql是关系型数据库，Key-Value的插入和查找基本都是O(1)的复杂度，而关系型数据库会涉及到索引的查找和插入，是对数级的复杂度（InnoDB有索引），但这个在InnoDB下并不是太大的问题，因为Mysql是多线程的，并且引入了MVCC(多版本并发控制），插入的时候不会锁表，还能更好的利用多核，所以不会因为并发在插入时造成太大 的性能问题。
然后看并发问题，应该指的是Mysql使用MyISAM时，数据的插入都会锁表，但不是死锁，只是这个时候针对单表的插入MySql的多线程并不能发挥优势，所有的数据只能一条一条插入，所以相对于Redis,最终的性能差异在磁盘和算法本身的复杂度上。
最后说说Redis的消息队列，Redis的线程模型是单线程的，所有的命令都是在一个命令队列里，一个接着一个执行，并不能并发执行。这种模型最大的优势是编程简单，并不会为并发带来优势，相反不能利用多核是其最大的弊病，这种模型基本都是利用NIO来解决并发问题。当然，Redis这样也就不会造成死锁，因为没有资源竞争，但MySql的死锁是可以通过良好的设计来避免的，所以消息队列并不是Redis性能高的原因。


开源软件进线程模型：

Redis：单进程单线程
Memcached：单进程多线程
Nginx： 多进程单线程

单进程单线程的Redis如何能够高并发：
http://blog.csdn.net/liupeng_qwert/article/details/77263187
https://www.zhihu.com/question/55818031
https://zhuanlan.zhihu.com/p/24252862?refer=belief